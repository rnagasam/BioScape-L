CS 694 Final Project

Attempt at an implementation of a (simplified) version of BioScape^L
[1].


Todo

  1. Run time checks in `build_process' (eval.erl)
     - cannot send message directly to a process
     - cannot recv messgae directly from a process
  2. Entity geometries
     - location in space
     - `mov' command
     - diffusion
     - random movement
     - `this' message
     - `build_process' should return a function with 2 parameters
  3. Parameters in process definitions
     - for private channels, other input
  4. Parser
  5. Type checker


Notes

Erlang repr (pi-calculus):

    TERM ::= { null }
           | { send, Chan, Msg, TERM }
           | { recv, Chan, Msg, TERM }
           | { new, Chan, TERM }
           | { spawn, [ TERM ] }
           | { repeat, TERM }


BioScape^L abstract syntax

    P, Q ::= 0                                         empty process
           | X(d)_d                          located entity instance
           | P | Q                              parallel composition
           | (va@d,d:chan{T}).P                          restriction

    M ::= pi.P [+ M]                      choice of prefixed process

    pi ::= delay@r                                             delay
         | !u(d)                                              output
         | ?u(x)                                               input
         | mov                                                  move

    N ::= M | (va@d,d:chan{T}).N                   restricted choice

    u ::= a | b | ... | x | y | ...                      identifiers

    d ::= u | c | this | d1,...,dn | () | d.i | op(d)    expressions

    v ::= a | b | ... | c | () | v1,...,vn         expression values

    T ::= chan{T} | fl | T1 x ... x Tn | Top         expresion types

    D ::= 0 | D,X(x:T) = N^{geom}                 entity definitions

    E ::= 0 | E,a@r,rad:chan{T}                 channel declarations

    G ::= 0 | G,X:T | G,u:T                         type environment


Obtaining entity locations (`place')

It might be convenient to have the entity send its location to the
channel when sending or receiving messages.  The alternative is to
have the `simul' process record the locations of all entities.  The
`channel' process then has to query `simul' to obtain location
information.

Note that all of this is required since the `channel' needs to know
where entities are.  Entities react only when they are "close-enough".


Strategies for reactions

What happens when entities are not close enough to react?  We might
choose to have them wait (while allowing diffusion) until a reaction
can take place, or we might discard the reaction and move on with the
rest of the program.


References

[1] Compagnoni, Adriana et al. “A Calculus of Located Entities.”
Electronic Proceedings in Theoretical Computer Science 144 (2014):
41–56. Crossref. Web.